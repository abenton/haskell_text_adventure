-- | This is the parser generated by Aeson as obtained by compiling
-- | Types.hs with the -ddump-splices flag

Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvRoom
  ======>
    Types.hs:29:1-23
    instance ToJSON AdvRoom where
        { toJSON
            = \ value[a23U]
                -> case value[a23U] of {
                     AdvRoom arg1[a23V] arg2[a23W]
                       -> object
                            [(T.pack "roomName" .= arg1[a23V]),
                             (T.pack "roomDesc" .= arg2[a23W])] } }
    instance FromJSON AdvRoom where
        { parseJSON
            = \ value[a23X]
                -> case value[a23X] of {
                     Object obj[a23Y]
                       -> ((AdvRoom Data.Functor.<$> (obj[a23Y] .: T.pack "roomName"))
                         Control.Applicative.<*>
                           (obj[a23Y] .: T.pack "roomDesc"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'Dir
  ======>
    Types.hs:34:1-19
    instance ToJSON Dir where
        { toJSON
            = \ value[a2qj]
                -> case value[a2qj] of {
                     N -> object
                            [(T.pack "N" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))]
                     S -> object
                            [(T.pack "S" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))]
                     E -> object
                            [(T.pack "E" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))]
                     W -> object
                            [(T.pack "W" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))]
                     U -> object
                            [(T.pack "U" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))]
                     D -> object
                            [(T.pack "D" .= toJSON (GHC.Types.[] :: [GHC.Unit.()]))] } }
    instance FromJSON Dir where
        { parseJSON
            = \ value[a2qk]
                -> case value[a2qk] of {
                     Object obj[a2ql]
                       -> case Data.Map.toList obj[a2ql] of {
                            [(conKey[a2qm], conVal[a2qn])]
                              -> case conKey[a2qm] of {
                                   _ | (conKey[a2qm] == T.pack "N")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qo]
                                            | Data.Vector.null arr[a2qo]
                                            -> Control.Applicative.pure N
                                          _ -> mzero }
                                     | (conKey[a2qm] == T.pack "S")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qp]
                                            | Data.Vector.null arr[a2qp]
                                            -> Control.Applicative.pure S
                                          _ -> mzero }
                                     | (conKey[a2qm] == T.pack "E")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qq]
                                            | Data.Vector.null arr[a2qq]
                                            -> Control.Applicative.pure E
                                          _ -> mzero }
                                     | (conKey[a2qm] == T.pack "W")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qr]
                                            | Data.Vector.null arr[a2qr]
                                            -> Control.Applicative.pure W
                                          _ -> mzero }
                                     | (conKey[a2qm] == T.pack "U")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qs]
                                            | Data.Vector.null arr[a2qs]
                                            -> Control.Applicative.pure U
                                          _ -> mzero }
                                     | (conKey[a2qm] == T.pack "D")
                                     -> case conVal[a2qn] of {
                                          Array arr[a2qt]
                                            | Data.Vector.null arr[a2qt]
                                            -> Control.Applicative.pure D
                                          _ -> mzero }
                                     | otherwise -> mzero }
                            _ -> mzero }
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvExit
  ======>
    Types.hs:42:1-23
    instance ToJSON AdvExit where
        { toJSON
            = \ value[a2sl]
                -> case value[a2sl] of {
                     AdvExit arg1[a2sm] arg2[a2sn]
                       -> object
                            [(T.pack "exitDir" .= arg1[a2sm]),
                             (T.pack "exitTo" .= arg2[a2sn])] } }
    instance FromJSON AdvExit where
        { parseJSON
            = \ value[a2so]
                -> case value[a2so] of {
                     Object obj[a2sp]
                       -> ((AdvExit Data.Functor.<$> (obj[a2sp] .: T.pack "exitDir"))
                         Control.Applicative.<*>
                           (obj[a2sp] .: T.pack "exitTo"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvLocation
  ======>
    Types.hs:51:1-27
    instance ToJSON AdvLocation where
        { toJSON
            = \ value[a2tt]
                -> case value[a2tt] of {
                     AdvLocation arg1[a2tu] arg2[a2tv] arg3[a2tw]
                       -> object
                            [(T.pack "locRoom" .= arg1[a2tu]),
                             (T.pack "locExits" .= arg2[a2tv]),
                             (T.pack "locObjects" .= arg3[a2tw])] } }
    instance FromJSON AdvLocation where
        { parseJSON
            = \ value[a2tx]
                -> case value[a2tx] of {
                     Object obj[a2ty]
                       -> (((AdvLocation Data.Functor.<$> (obj[a2ty] .: T.pack "locRoom"))
                          Control.Applicative.<*>
                            (obj[a2ty] .: T.pack "locExits"))
                         Control.Applicative.<*>
                           (obj[a2ty] .: T.pack "locObjects"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvObject
  ======>
    Types.hs:62:1-25
    instance ToJSON AdvObject where
        { toJSON
            = \ value[a2uO]
                -> case value[a2uO] of {
                     AdvObject arg1[a2uP] arg2[a2uQ] arg3[a2uR] arg4[a2uS] arg5[a2uT]
                       -> object
                            [(T.pack "objName" .= arg1[a2uP]),
                             (T.pack "objType" .= arg2[a2uQ]), (T.pack "objDesc" .= arg3[a2uR]),
                             (T.pack "objPickup" .= arg4[a2uS]),
                             (T.pack "objDiscard" .= arg5[a2uT])] } }
    instance FromJSON AdvObject where
        { parseJSON
            = \ value[a2uU]
                -> case value[a2uU] of {
                     Object obj[a2uV]
                       -> (((((AdvObject Data.Functor.<$> (obj[a2uV] .: T.pack "objName"))
                            Control.Applicative.<*>
                              (obj[a2uV] .: T.pack "objType"))
                           Control.Applicative.<*>
                             (obj[a2uV] .: T.pack "objDesc"))
                          Control.Applicative.<*>
                            (obj[a2uV] .: T.pack "objPickup"))
                         Control.Applicative.<*>
                           (obj[a2uV] .: T.pack "objDiscard"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvPlayer
  ======>
    Types.hs:70:1-25
    instance ToJSON AdvPlayer where
        { toJSON
            = \ value[a2w7]
                -> case value[a2w7] of {
                     AdvPlayer arg1[a2w8] arg2[a2w9]
                       -> object
                            [(T.pack "playerAt" .= arg1[a2w8]),
                             (T.pack "playerHas" .= arg2[a2w9])] } }
    instance FromJSON AdvPlayer where
        { parseJSON
            = \ value[a2wa]
                -> case value[a2wa] of {
                     Object obj[a2wb]
                       -> ((AdvPlayer Data.Functor.<$> (obj[a2wb] .: T.pack "playerAt"))
                         Control.Applicative.<*>
                           (obj[a2wb] .: T.pack "playerHas"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvMonster
  ======>
    Types.hs:79:1-26
    instance ToJSON AdvMonster where
        { toJSON
            = \ value[a2xd]
                -> case value[a2xd] of {
                     AdvMonster arg1[a2xe] arg2[a2xf] arg3[a2xg]
                       -> object
                            [(T.pack "monsterDesc" .= arg1[a2xe]),
                             (T.pack "monsterAt" .= arg2[a2xf]),
                             (T.pack "monsterHas" .= arg3[a2xg])] } }
    instance FromJSON AdvMonster where
        { parseJSON
            = \ value[a2xh]
                -> case value[a2xh] of {
                     Object obj[a2xi]
                       -> (((AdvMonster
                           Data.Functor.<$>
                             (obj[a2xi] .: T.pack "monsterDesc"))
                          Control.Applicative.<*>
                            (obj[a2xi] .: T.pack "monsterAt"))
                         Control.Applicative.<*>
                           (obj[a2xi] .: T.pack "monsterHas"))
                     _ -> mzero } }
Types.hs:1:1: Splicing declarations
    deriveJSON id 'AdvConfig
  ======>
    Types.hs:95:1-25
    instance ToJSON AdvConfig where
        { toJSON
            = \ value[a2yZ]
                -> case value[a2yZ] of {
                     AdvConfig arg1[a2z0] arg2[a2z1] arg3[a2z2] arg4[a2z3]
                       -> object
                            [(T.pack "locations" .= arg1[a2z0]),
                             (T.pack "objects" .= arg2[a2z1]), (T.pack "players" .= arg3[a2z2]),
                             (T.pack "monsters" .= arg4[a2z3])] } }
    instance FromJSON AdvConfig where
        { parseJSON
            = \ value[a2z4]
                -> case value[a2z4] of {
                     Object obj[a2z5]
                       -> ((((AdvConfig
                            Data.Functor.<$>
                              (obj[a2z5] .: T.pack "locations"))
                           Control.Applicative.<*>
                             (obj[a2z5] .: T.pack "objects"))
                          Control.Applicative.<*>
                            (obj[a2z5] .: T.pack "players"))
                         Control.Applicative.<*>
                           (obj[a2z5] .: T.pack "monsters"))
                     _ -> mzero } }
